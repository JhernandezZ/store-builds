{
  "version": 3,
  "file": "actions-stream.js",
  "sources": [
    "ng://@ngxs/store/packages/store/src/actions-stream.ts"
  ],
  "sourcesContent": [
    "import { Injectable, NgZone } from '@angular/core';\r\nimport { Observable, Subject } from 'rxjs';\r\n\r\nimport { enterZone } from './operators/zone';\r\n\r\n/**\r\n * Status of a dispatched action\r\n */\r\nexport const enum ActionStatus {\r\n  Dispatched = 'DISPATCHED',\r\n  Successful = 'SUCCESSFUL',\r\n  Canceled = 'CANCELED',\r\n  Errored = 'ERRORED'\r\n}\r\n\r\nexport interface ActionContext {\r\n  status: ActionStatus;\r\n  action: any;\r\n  error?: Error;\r\n}\r\n\r\n/**\r\n * Custom Subject that ensures that subscribers are notified of values in the order that they arrived.\r\n * A standard Subject does not have this guarantee.\r\n * For example, given the following code:\r\n * ```typescript\r\n *   const subject = new Subject<string>();\r\n     subject.subscribe(value => {\r\n       if (value === 'start') subject.next('end');\r\n     });\r\n     subject.subscribe(value => { });\r\n     subject.next('start');\r\n * ```\r\n * When `subject` is a standard `Subject<T>` the second subscriber would recieve `end` and then `start`.\r\n * When `subject` is a `OrderedSubject<T>` the second subscriber would recieve `start` and then `end`.\r\n */\r\nexport class OrderedSubject<T> extends Subject<T> {\r\n  private _itemQueue: T[] = [];\r\n  private _busyPushingNext = false;\r\n\r\n  next(value?: T): void {\r\n    if (this._busyPushingNext) {\r\n      this._itemQueue.unshift(value);\r\n      return;\r\n    }\r\n    this._busyPushingNext = true;\r\n    super.next(value);\r\n    while (this._itemQueue.length > 0) {\r\n      const nextValue = this._itemQueue.pop();\r\n      super.next(nextValue);\r\n    }\r\n    this._busyPushingNext = false;\r\n  }\r\n}\r\n\r\n/**\r\n * Internal Action stream that is emitted anytime an action is dispatched.\r\n */\r\n@Injectable()\r\nexport class InternalActions extends OrderedSubject<ActionContext> {}\r\n\r\n/**\r\n * Action stream that is emitted anytime an action is dispatched.\r\n *\r\n * You can listen to this in services to react without stores.\r\n */\r\n@Injectable()\r\nexport class Actions extends Observable<any> {\r\n  constructor(actions$: InternalActions, ngZone: NgZone) {\r\n    super(observer => {\r\n      actions$\r\n        .pipe(enterZone(ngZone))\r\n        .subscribe(res => observer.next(res), err => observer.error(err), () => observer.complete());\r\n    });\r\n  }\r\n}\r\n"
  ],
  "names": [],
  "mappings": "AAAA,OAAO,EAAE,UAAU,EAAE,MAAM,EAAE,MAAM,eAAe,CAAC;AACnD,OAAO,EAAE,UAAU,EAAE,OAAO,EAAE,MAAM,MAAM,CAAC;AAE3C,OAAO,EAAE,SAAS,EAAE,MAAM,kBAAkB,CAAC;;;;;;;;;;;;;;;;AAiC7C,MAAM,qBAAyB,SAAQ,OAAU;;;0BACrB,EAAE;gCACD,KAAK;;IAEhC,IAAI,CAAC,KAAS;QACZ,EAAE,CAAC,CAAC,IAAI,CAAC,gBAAgB,CAAC,CAAC,CAAC;YAC1B,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;YAC/B,MAAM,CAAC;SACR;QACD,IAAI,CAAC,gBAAgB,GAAG,IAAI,CAAC;QAC7B,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QAClB,OAAO,IAAI,CAAC,UAAU,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;YAClC,MAAM,SAAS,GAAG,IAAI,CAAC,UAAU,CAAC,GAAG,EAAE,CAAC;YACxC,KAAK,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;SACvB;QACD,IAAI,CAAC,gBAAgB,GAAG,KAAK,CAAC;KAC/B;CACF;;;;AAMD,MAAM,sBAAuB,SAAQ,cAA6B;;;YADjE,UAAU;;;;;;;AASX,MAAM,cAAe,SAAQ,UAAe;IAC1C,YAAY,QAAyB,EAAE,MAAc;QACnD,KAAK,CAAC,QAAQ,CAAC,EAAE;YACf,QAAQ;iBACL,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC;iBACvB,SAAS,CAAC,GAAG,CAAC,EAAE,CAAC,QAAQ,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,GAAG,CAAC,EAAE,CAAC,QAAQ,CAAC,KAAK,CAAC,GAAG,CAAC,EAAE,GAAG,EAAE,CAAC,QAAQ,CAAC,QAAQ,EAAE,CAAC,CAAC;SAChG,CAAC,CAAC;KACJ;;;YARF,UAAU;;;;YAPE,eAAe;YA3DP,MAAM"
}
